ğŸˆï»¿WeğŸ˜ºâœŒ trained a large , deep convolutional neural networkğŸ˜™ğŸ˜† to classifyğŸ˜­â€ğŸ™†ğŸ˜” the 1. 2 million high-resolutionğŸ””ğŸ”« images in the ImageNet LSVRC-2010 contest into the 1000 different classes. On the test data , we achieved top-1 and top-5 errorğŸ rates of 37. 5 %ğŸ¦ and 17. 0 % which is considerably better than the previous state-of-the-art. The neural networkğŸ’ªğŸğŸ€ , which has 60 million parameters and 650,000 neurons , consists of five convolutional layers , some of which are followed by max-pooling layers , and three fully-connected layers with a final 1000-way softmaxğŸ“¼ï¸ğŸ†ğŸ‘…. To makeğŸ˜—â­• trainingğŸ­ğŸŒ› fasterğŸŒ›ğŸ‘¯â­• , we used non-saturating neurons and a very efficient GPUğŸ’” implementationğŸ“¼ğŸ¹ of the convolutionğŸ“¼ï¸â™¨ğŸ¸ operationğŸ¸ğŸ»ğŸ¤—. To reduce overfitting in the fully-connected layers we employed a recently-developed regularization method called â€œdropoutâ€ that proved to beğŸ’° veryğŸŒŸ effective. We alsoğŸ¢ğŸ‘ğŸ’™ enteredğŸ™‚ğŸ†— a variant of this model in the ILSVRC-2012 competition and achievedğŸ’© a winning top-5 test errorğŸ™ƒğŸ†— rateğŸºğŸ‘¿ğŸ˜µ of 15. 3 % , compared to 26. 2 % achieved by the second-best entry. Current approaches to objectğŸŒµğŸ¦ recognition make essential useğŸ‘„ of machine learningğŸ˜ˆ methods. To improveğŸ»ğŸš€ğŸ† their performance , we can collect larger datasets , learn more powerful models , and useï¸ğŸ’› better techniques for preventingğŸ˜‚ğŸ’¸ğŸ˜º overfittingğŸ˜Œ. Until recentlyğŸ˜© , datasets of labeled images were relatively small â€” on the order of tens of thousands of images ( eğŸ˜­. , NORB [ 16 ] , Caltech-101/256 [ 8 , 9 ] , and CIFAR-10/100 [ğŸ“ 12 ] ). Simple recognitionğŸ‘ŒğŸ˜Š tasks can beğŸ solved quite well with datasets of this size , especially if they areğŸ‘¯ augmentedğŸ˜™ with label-preserving transformations. For example , the currentbest errorğŸ‘¿ rate on the MNIST digit-recognition taskâŒğŸ³ ( < 0. 3 %ğŸ˜©ğŸ·ğŸ“ ) approachesğŸ˜³ human performanceğŸ˜ [ğŸ†ğŸ˜® 4 ]ğŸ†. But objects in realistic settings exhibit considerable variability , so to learn to recognize them it is necessary to useğŸ—¿ğŸ˜¨ much largerğŸ”” trainingğŸ˜³ sets. And indeed , the shortcomings of small image datasets haveğŸ˜ª been widelyğŸ recognized ( eï¸âš½ğŸ¹. , PintoğŸ˜¦ et alğŸ”«. [ 21 ] ) , but it has only recently become possible to collect labeled datasets with millions of images. The new largerğŸ˜— datasets include LabelMe [ 23 ] , which consists of hundreds of thousands of fully-segmented images , and ImageNet [ 6 ] , which consists of over 15 million labeled high-resolutionğŸ€ images in over 22,000 categories. To learn about thousands of objects from millions of images , we need a modelğŸ“ with a large learning capacityğŸ˜™ğŸ˜¹ğŸ˜Œ. ğŸ˜©However , the immense complexity of the object recognition task means that this problem can not be specified even by a dataset as large as ImageNet , so our model should also have lots of prior knowledge to compensateğŸ³ for all the data we donâ€™t haveğŸ’€ğŸ’€. Convolutional neural networks ( CNNsğŸ˜©ğŸ˜® ) constitute one such class of models [ 16 , 11 , 13 , 18 , 15 , 22 , 26 ]ğŸ¢ğŸ˜´ğŸµ. Their capacityï¸ğŸ’› can beğŸ’ controlledğŸ‘¯ by varying their depth and breadth , and they also make strong and mostly correct assumptions about the nature of images ( namely , stationarity of statistics and localityğŸ˜š of pixel dependencies ). ğŸ†ğŸ‘…ThusğŸš¶ , comparedğŸğŸ™‰ to standard feedforwardğŸ”§ğŸ“¼ neural networks with similarly-sized layers , CNNs have much fewer connections and parameters and so they are easier to train , while their theoretically-best performance isğŸŒ likely to beğŸ—¿ğŸ˜«ğŸ‘¿ onlyğŸ“ğŸ˜†ğŸ¦ slightlyğŸÂ®ğŸ‘© worseğŸ˜ğŸ‡ğŸ. Despite the attractive qualities of CNNs , and despite the relative efficiency of their local architecture , they have still been prohibitively expensive to apply in large scale to high-resolution images. ğŸ˜‡LuckilyğŸ˜Œ , current GPUs , paired with a highly-optimized implementation of 2D convolution , are powerful enough to facilitate the training of interestingly-large CNNs , and recent datasets such as ImageNet contain enough labeled examples to train such models without severe overfittingğŸ˜°. The specific contributions of this paperğŸ˜¢ğŸ€ğŸ’° areğŸ™ˆ as followsğŸ’ : we trained one of the largest convolutional neural networks to date on the subsets of ImageNet used in the ILSVRC-2010 and ILSVRC-2012 competitions [ 2 ] and achieved by far the best results everğŸ’¸ğŸ¹ğŸ˜— reportedğŸ†’ğŸ’°ğŸ‘ on these datasets. We wroteğŸ˜©ğŸ˜³ğŸ˜¨ a highly-optimized GPUğŸ‘…ğŸ· implementation of 2D convolution and all the other operations inherent in training convolutional neural networks , which we makeğŸš¶â¤ğŸ‘‘ available publiclyğŸ˜±ğŸ“¼ï¸ğŸ†. Our networkğŸ’™ğŸ containsğŸ˜· a numberğŸ‘ of new and unusual features which improve its performance and reduce its training timeğŸ¹ , which are detailedğŸ‘© in SectionğŸ˜°ğŸ˜œğŸ‘½ 3. The size of our network made overfitting a significant problem , even with 1. 2 million labeled training examples , so we used several effective techniques for preventing overfitting , which areğŸ± describedğŸ™ˆğŸ‘„ in Sectionâš¾ 4. Our final networkğŸ˜”ğŸ˜«ğŸ’€ contains five convolutional and three fully-connected layers , and this depth seems to be important : we found that removing any convolutional layer ( each of which contains no more than 1 % of the modelâ€™s parameters ) resultedğŸ’šğŸ˜«ğŸ˜« in inferior performanceğŸ˜ğŸ‘¿ğŸ˜¿. In the end , the networkâ€™s sizeğŸŒ› isğŸŒ limited mainly by the amount of memory available on current GPUs and by the amount of training timeâš¡ that we are willing to tolerateğŸ˜š. Our networkâ€ğŸ™† takes between five and six days to train on two GTXğŸ˜® 580 3GB GPUsğŸ˜­ğŸ˜®ğŸ‡. All of our experiments suggest that our results can be improved simply by waiting for faster GPUs and bigger datasets to become available. ğŸ‘¿ImageNetğŸ˜±ğŸš¶ isğŸ˜® a datasetğŸ˜†â­•ğŸš¶ of over 15 million labeled high-resolution images belonging to roughlyğŸğŸ˜´ 22,000 categories. The images wereÂ® collectedï¸ğŸ™ from the web and labeled by human labelers using Amazonâ€™s MechanicalğŸ‡¨ğŸ‡¦ TurkğŸ”” crowd-sourcing toolğŸ·ğŸ””ğŸ˜¶. ğŸğŸ˜¬Startingâš¾ in 2010 , as part of the Pascal Visual Object Challenge , an annual competition called the ImageNet Large-Scale Visual Recognition Challenge ( ILSVRCğŸ˜º ) hasğŸ€ğŸ˜˜ğŸ˜» beenâ€ğŸ™†ğŸš—ğŸ˜´ heldğŸ³ğŸ€ğŸ™‚. ILSVRCğŸ‘¿ usesğŸğŸ˜¹ a subset of ImageNet with roughly 1000 images in each of 1000 categories. In all , there are roughly 1. 2 million trainingğŸ“â­•â¤ images , 50,000 validation images , and 150,000 testingğŸ˜—ğŸ‘»ğŸ¤” images. ğŸ‘©ğŸ˜˜ILSVRC-2010ğŸ˜³ isğŸ˜¶Â®Â® the only version of ILSVRCğŸ’« for which the test set labels are available , so this is the version on which we performedğŸ‘©ğŸ™‰ most of our experiments. Since we alsoğŸ™‚ğŸºâ˜• enteredğŸ‡¨ğŸ‡¦ğŸ˜³ our model in the ILSVRC-2012 competition , in Section 6 we report our results on this version of the dataset as well , for which test set labels areğŸ’ƒğŸğŸ˜ˆ unavailable. On ImageNetğŸ˜° , it is customary to report two error rates : top-1 and top-5 , where the top-5 error rate is the fraction of test images for which the correct label is not among the five labels considered most probable by the modelğŸ˜«. ImageNet consists of variable-resolution images , while our system requires a constant input dimensionality. ğŸ—¿ğŸ˜¶ThereforeğŸ˜¨ , we down-sampled the images to a fixed resolutionğŸ’© of 256 Ã— 256. ğŸ˜ºğŸ˜®GivenÂ® a rectangular image , we first rescaled the image such that the shorter side was of length 256 , and then cropped out the central 256Ã—256 patchğŸ˜ğŸ™‰ from the resultingâš¾ğŸ˜®ğŸ‡¬ğŸ‡§ imageğŸğŸ˜ˆğŸ™‰. We didğŸ’£ğŸ˜µğŸ˜† notğŸ˜¶ pre-processğŸµ the images in any other way , except for subtracting the mean activity over the training set from each pixelğŸ˜ŒğŸ˜»ğŸ˜¶. So we trainedğŸ’ our network on the ( centered ) raw RGB values of the pixels. The architecture of our networkğŸ˜Œ is summarized in FigureğŸ˜ª 2. It containsğŸ˜ª eight learnedğŸ‘„ğŸ”” layers â€” five convolutional and three fully-connected. Below , we describeğŸ˜‡ some of the novel or unusual features of our networkâ€™s architectureğŸ’. Sections 3. 1-3. 4 are sorted according to our estimation of their importance , with the most important first. The standard wayğŸ˜¹ğŸ˜®âœŒ to modelï¸ğŸ™ğŸ“¼ğŸ”” a neuronâ€™s output f as a function of its input x is with f ( x ) = tanh ( x ) or f ( x ) = ( 1 + e âˆ’xğŸ˜µğŸ’£ğŸš¶ ) âˆ’1ğŸ¦ğŸ˜™ğŸ˜‘. In terms of trainingğŸ˜Œ time with gradient descent , these saturating nonlinearities are much slower than the non-saturating nonlinearity f ( x ) = max ( 0 , xğŸ˜®ğŸ¦ğŸ˜´ ). ğŸ˜FollowingğŸ’…ğŸ‡¬ğŸ‡§ NairğŸğŸš¶ and HintonğŸ˜­ğŸ˜”ï¸âš½ [ğŸ¹ğŸ“ğŸ¤” 20 ]ğŸ , we refer to neurons with this nonlinearity as Rectified LinearğŸ‘©ğŸ˜¨ UnitsğŸ ( ReLUsğŸ’«ğŸ˜´ğŸ˜± ). Deep convolutional neural networks with ReLUs train several times faster than their equivalents with tanh units. This isğŸ™…ğŸ’¸ğŸ˜· demonstratedğŸ˜ğŸ˜¦ğŸ˜’ in FigureğŸ’š 1 , which shows the number of iterations required to reach 25 % training error on the CIFAR-10 dataset for a particular four-layer convolutionalğŸ‘¿ğŸ’£ networkğŸ’£ğŸš½ğŸ˜ª. This plotï¸ğŸ†â­•ğŸ˜´ showsğŸ“¼Â®ğŸ‘» that we would not have been able to experiment with such large neural networks for this work if we hadğŸ˜¨ used traditional saturatingğŸ’…ğŸ“ neuronğŸ“¼ğŸ˜® models. We areğŸ¤”ğŸ³ notğŸ“ğŸ“¼ğŸ˜® the first to consider alternatives to traditional neuron models in CNNsğŸğŸ˜¶ğŸ­. For example , Jarrett etğŸ™„ğŸ—¿ alğŸ·ğŸ¤”ğŸ’…. ğŸ“ğŸ˜¤[ 11 ] claim that the nonlinearity f ( x ) = |tanh ( x ) | works particularly well with their type of contrast normalization followed by local average pooling on the Caltech-101ğŸ’ğŸ’ª datasetğŸ™‚ğŸ¤. âŒğŸ±HoweverğŸ˜ƒ , on this datasetğŸ’« the primary concern is preventing overfitting , so the effect they are observing is different from the accelerated ability to fit the training set which we reportğŸ˜ğŸ‘Œ when usingğŸŒğŸ’£ğŸ˜Š ReLUsğŸ¢ğŸ’°âŒ. ğŸ¤—ğŸ˜‰FasterğŸ’« learningâ€ğŸ™†ğŸ†’ hasğŸ‘ğŸ˜†ğŸ’° a great influenceğŸ˜™ğŸ’ğŸ™Š on the performance of large models trainedğŸ†’ğŸ’ğŸ™ on large datasets. A single GTXğŸ™‰ 580 GPU has only 3GB of memory , which limits the maximum size of the networks that can be trainedğŸ™‰ğŸ˜¦ on it. It turns out that 1. 2 million trainingğŸ¸ examples areğŸ’”ğŸŒ›ğŸŒŸ enough to train networks which are too big to fit on one GPUğŸ˜ŒğŸ»â›„. Therefore we spread the net across two GPUsğŸ¦ğŸ˜©ğŸ˜‘. Current GPUsğŸâ­•ğŸ˜Œ areğŸ†—ğŸ”§Â® particularlyğŸ‡¬ğŸ‡§ğŸ¦ğŸ¢ well-suited to cross-GPU parallelization , as they are able to read from and write to one anotherâ€™s memory directly , without goingğŸˆâ­• through hostğŸ“ğŸ˜» machineğŸ˜±ğŸ¢ğŸ˜´ memoryğŸ¦ğŸ‡¨ğŸ‡¦ğŸ˜®. The parallelizationğŸºï¸ğŸ™ğŸº schemeğŸ€ that we employ essentially puts half of the kernels ( or neurons ) on each GPU , with one additional trick : the GPUs communicateğŸ˜º onlyğŸ¢ğŸŒ›ğŸ¸ in certain layers. This meansğŸ˜™ğŸš¶ that , for example , the kernels of layer 3 take input from all kernel maps in layerğŸ¸ğŸ’ª 2. ğŸ˜©HoweverğŸ˜­ğŸ‘© , kernels in layerğŸ˜ˆ 4 take input only from those kernel maps in layer 3 which resideğŸ”« on the same GPUï¸âš½ğŸâ€ğŸ™†. Choosing the patternï¸ğŸ™ğŸ˜¬ of connectivity isğŸ’© a problem for cross-validation , but this allows us to precisely tune the amount of communication until it is an acceptable fractionğŸ¸ of the amountğŸŒ of computationğŸ“ğŸŒ›. The resultant architecture isğŸ’ªğŸ˜‘ğŸ“ somewhat similar to that of the â€œcolumnarâ€ CNN employedğŸ—¿ğŸ’…ğŸ˜ˆ by CireÂ¸san et alğŸ˜‘â€ğŸ™†ğŸ”§. [ğŸ˜‘ğŸ””ğŸ”§ 5 ] , except that our columns are not independent ( see Figure 2 ). This schemeğŸğŸ‘ğŸ™… reduces our top-1 and top-5 error rates by 1. 7 % and 1. 2 %ğŸ¤ğŸ˜œğŸ¸ , respectivelyğŸ¤—ğŸ¹ , as compared with a net with half as many kernels in each convolutional layerğŸ“¼ trainedğŸ’¦ğŸ˜‡ on one GPUğŸ¸ğŸ’šğŸ˜. The two-GPU net takes slightly less time to train than the one-GPU net2ğŸğŸ˜®ğŸ—¿. ReLUs have the desirable property that they doğŸ’£ not require input normalizationğŸºğŸ™‚ to prevent them from saturatingğŸ€ğŸ“ğŸ˜‡. If at least some training examples produce a positive input to a ReLU , learningğŸ˜Š will happen in that neuronğŸ±. HoweverğŸ˜­ğŸ¢ , we still findâ€ğŸ™† that the following local normalization schemeğŸ¦ aids generalization. ğŸ‘©ğŸ·ğŸ“¼Denoting by a iğŸ˜†â¤ğŸ˜® xğŸ˜» , y the activityâ­• of a neuron computed by applying kernel i at position ( x , y ) and then applying the ReLU nonlinearity , the response-normalized activity b i x , y is given by the expression where the sum runs over n â€œadjacentâ€ kernel maps at the same spatial position , and N is the total number of kernels in the layerğŸ”§ğŸ”§ğŸ˜¹. The orderingğŸ™ŠğŸ˜œğŸ­ of the kernel maps is of course arbitrary and determinedğŸ‘„ before trainingğŸ˜… begins. This sort of responseğŸŒŸ normalization implements a form of lateral inhibition inspired by the type found in real neurons , creating competition for big activities amongst neuronï¸ğŸ† outputsğŸŒŸ computedğŸ™ˆğŸ“¼ğŸº usingğŸ³ğŸ­ different kernels. The constants kğŸ‘»ğŸ’€ğŸ’ , nğŸ± , Î± , and Î² are hyper-parameters whose values are determined using a validation set ; we used k = 2 , n = 5 , Î±ğŸŒœ = 10âˆ’4 , and Î²ğŸ’° =ğŸ˜¨ğŸ­ 0. We appliedğŸ‘ this normalizationâœŒ after applyingï¸ğŸ™ğŸ‘½ the ReLU nonlinearity in certain layers ( seeğŸºğŸ‘„ SectionğŸ™ŠğŸŒğŸ’• 3. 5 ). This scheme bears some resemblance to the local contrast normalization scheme of Jarrett et al. ğŸš¶[ğŸ’« 11 ]ğŸ˜®ğŸ¦ğŸ˜³ , but ours would be more correctly termed â€œbrightness normalizationâ€ , since we do notğŸ˜¶ğŸ—¿ subtractğŸ‘„ğŸ””ğŸ­ the mean activityğŸ¤”ğŸ˜´ğŸ˜®. ğŸResponseğŸŒğŸ‘ normalizationğŸ’€ reducesÂ® our top-1 and top-5 error rates by 1. 4 %ğŸ‘… and 1. 2 %ğŸ‘½ğŸ’œğŸŒœ , respectively. We alsoğŸ¤‘ verifiedğŸŒğŸ˜‚ğŸ¤” the effectiveness of this scheme on the CIFAR-10 dataset : a four-layer CNN achieved a 13 % test error rate without normalization and 11 % with normalizationğŸ˜•ğŸ˜·. PoolingğŸ˜® layers in CNNs summarizeğŸ˜¹ the outputs of neighboring groups of neurons in the same kernel mapğŸ†ğŸ™‰ğŸ. ğŸ¦ğŸ’…Traditionallyï¸ğŸ† , the neighborhoods summarized by adjacent poolingğŸ˜¨ units do notğŸ­ğŸ˜³ overlapâ¤ğŸ˜´ ( eğŸ˜™â¤ğŸŒ. , [ 17 , 11 , 4 ]ğŸ‘© ). To beğŸ˜‘ more precise , a poolingâ€ğŸ™† layer can be thought of as consisting of a grid of pooling units spaced s pixels apart , each summarizing a neighborhood of size z Ã— z centered at the locationğŸ˜®ğŸ³ of the pooling unitğŸ¸Â®ğŸ“¼. If we setğŸ‡¬ğŸ‡§ğŸ†ğŸ˜™ s = z , we obtain traditional local poolingğŸ˜± as commonlyğŸŒ½â­• employedğŸ¸ğŸ˜±ğŸ“ in CNNsğŸŒµğŸˆğŸ˜³. If we setğŸ˜ s < zâš¾ , we obtain overlappingğŸŒµ poolingğŸ¢â¤ğŸŒ. This is what we useğŸ‡ throughout our networkğŸŒ½ , with s = 2 and zğŸ˜®ğŸŒµ =ğŸš¶ 3. This scheme reduces the top-1 and top-5 error rates by 0. 4 %ğŸŒï¸ğŸ™ğŸ’£ and 0. 3 % , respectivelyğŸ¤ , as compared with the non-overlapping scheme s = 2 , z = 2 , which produces output of equivalent dimensions. We generally observeğŸ˜· during training that models with overlapping pooling find it slightly more difficult to overfit. ğŸ»NowğŸš—ğŸ‘½ we areğŸ¹ ready to describeâœŒ the overall architectureğŸ¸ of our CNNğŸŒ›ğŸ˜ğŸ». As depictedğŸ¹ in FigureğŸ‘» 2 , the net contains eight layers with weights ; the first five are convolutional and the remainingğŸ³ğŸ˜³ğŸ¦ three are fullyconnectedâœŒğŸ™„ğŸ˜º. The outputğŸ’©ğŸ†—ğŸ˜‘ of the last fully-connected layerğŸ‘¿ is fed to a 1000-way softmax which producesÂ® a distributionğŸ˜ˆğŸ˜¶ over the 1000 classğŸ‡¬ğŸ‡§ğŸ†—ğŸ¤” labels. Our networkğŸğŸ”§ğŸ“ maximizesï¸ğŸ™ğŸ‘‘ the multinomial logistic regression objective , which is equivalent to maximizing the average across training cases of the log-probability of the correct labelğŸğŸˆ under the predictionğŸ˜†ğŸ·ğŸ˜‘ distributionğŸğŸ‘©ğŸ”§. The kernels of the second , fourth , and fifth convolutional layers are connected only to those kernel maps in the previous layer which reside on the same GPU ( seeâš¾ğŸ¤” FigureğŸ˜”ğŸ˜©ğŸ‡¨ğŸ‡¦ 2 ). The kernels of the third convolutional layer are connected to all kernel maps in the second layerğŸ˜™. The neurons in the fullyconnected layers are connected to all neurons in the previous layer. ğŸ‘©ğŸResponse-normalization layers follow the first and second convolutional layers. Max-pooling layers , of the kindâŒğŸ’ğŸ‘¾ describedğŸ‘ in Sectionâ›„ğŸ‘ 3. 4 , followğŸ‡¬ğŸ‡§âœŒğŸ’… both response-normalization layers as wellï¸ğŸ™ğŸŒ as the fifth convolutional layerğŸ‘¯ğŸ»ğŸ‘½. The ReLUğŸ˜» non-linearityğŸ˜³ğŸ³ is applied to the output of every convolutional and fully-connected layerğŸ””ğŸ‘©ğŸ”§. The first convolutional layerğŸ˜™ğŸ³ğŸ³ filtersğŸ˜ªğŸ­ the 224Ã—224Ã—3 input image with 96 kernels of size 11Ã—11Ã—3 with a stride of 4 pixels ( this is the distance between the receptive field centers of neighboring Figure 2 : An illustration of the architecture of our CNN , explicitly showing the delineationğŸ—¿ of responsibilities between the two GPUsğŸ˜¦ğŸ†ğŸ˜‘. One GPUğŸ¦ğŸµğŸ˜º runsğŸ˜ the layer-parts at the top of the figure while the other runs the layer-parts at the bottomğŸ†—ğŸ˜. The GPUsğŸ“ communicate only at certain layers. The networkâ€™s inputğŸ””ğŸˆğŸ’… is 150,528-dimensional , and the number of neurons in the networkâ€™s remaining layers isğŸ˜®ğŸ given by 253,440â€“186,624â€“64,896â€“64,896â€“43,264â€“ 4096â€“4096â€“1000. neurons in a kernel mapğŸ˜¦ï¸ğŸ™ ). The second convolutional layerğŸ‡¨ğŸ‡¦ğŸ“¼ takesğŸ˜—ğŸ“ğŸ’… as inputğŸ”§ the ( response-normalized and pooled ) output of the first convolutional layer and filters it with 256 kernels of sizeğŸŒğŸ˜»ğŸ˜¶ 5 Ã—ğŸ˜¹ğŸ¹ğŸ˜˜ 5 Ã—ğŸ‡ğŸ”§ 48. The third , fourth , and fifth convolutional layers are connected to one another without any interveningğŸ† pooling or normalizationğŸ¦ğŸ“¼â€ğŸ™† layers. The third convolutional layerğŸ‘„ğŸ’«ğŸ”” has 384 kernels of size 3 Ã— 3 Ã— 256 connected to the ( normalized , pooled ) outputs of the second convolutional layerğŸ˜¨ğŸ˜™ğŸ‘…. The fourth convolutional layerğŸ—¿ has 384 kernels of size 3 Ã— 3 Ã— 192 , and the fifth convolutional layer has 256 kernels of sizeğŸ”” 3 Ã—ğŸ˜³ 3 Ã—ğŸ—¿ğŸ‘„ 192. The fully-connected layers haveğŸ—¿ 4096 neurons each. Our neural networkğŸ˜³ architectureğŸ’ªğŸ’« has 60 million parameters. Although the 1000 classes of ILSVRCï¸ğŸ™ make each training example impose 10 bits of constraint on the mapping from image to label , this turns out to be insufficient to learn soğŸ˜šğŸ”§ğŸ˜¢ many parameters without considerable overfittingğŸ™ˆğŸš—ğŸŒ›. Below , we describe the two primary ways in which we combat overfittingï¸âš½. The easiest and most common methodğŸ‘Œ to reduce overfitting on image data is to artificially enlarge the dataset using label-preserving transformations ( eğŸ™ƒ. , [ 25 , 4 , 5 ]ğŸ‡ ). We employğŸğŸŒğŸ‘» two distinct forms of data augmentation , both of which allow transformed images to be produced from the original images with very little computation , so the transformed images do not need to beğŸğŸ·ğŸ˜ storedğŸ’œğŸ˜ on diskâš¾ğŸ¸ğŸ‘¾. In our implementationğŸš¶ğŸ˜± , the transformed images are generated in Python code on the CPU while the GPUğŸ‘© is training on the previous batchğŸ˜‘ğŸ˜®ğŸ˜´ of images. So these data augmentationğŸ¹ğŸ˜— schemes are , in effectğŸ™ˆ , computationallyğŸ™ˆ free. The first form of data augmentation consists of generating imageğŸŒ½ translations and horizontal reflections. We doğŸ¢ğŸ’©ğŸ‘„ this by extracting random 224 Ã— 224 patches ( and their horizontal reflections ) from the 256Ã—256 images and training our networkğŸ˜®ğŸ—¿ on these extracted patches4ğŸ˜»ğŸ‘…ğŸ†. This increasesğŸ“¼ğŸ¤” the sizeğŸ“ğŸ˜®ğŸ˜® of our trainingğŸ¤” set by a factor of 2048 , though the resulting training examples are , of courseğŸ˜™ğŸ˜ğŸ¹ , highlyğŸ“ğŸ˜´ğŸ‘¿ interdependent. Without this schemeğŸ˜«ğŸ˜«ğŸ˜° , our network suffers from substantial overfitting , which would have forced us to useğŸ˜¿ğŸ˜¬ğŸ’” much smallerğŸ˜”â˜•ğŸ’” networks. At testğŸ»ğŸ˜¦ğŸ¸ timeğŸğŸŒšğŸ˜µ , the networkğŸŒğŸ˜Œ makesğŸ‘½ğŸ˜—ğŸ™Š a prediction by extracting five 224 Ã— 224 patches ( the four corner patches and the center patch ) as well as their horizontal reflections ( hence ten patches in all ) , and averaging the predictions made by the networkâ€™s softmax layerğŸŒ½ğŸ‘„ğŸ‘½ on the tenğŸ’…ğŸˆğŸ’ patches. The second formğŸ˜ª of data augmentation consists of altering the intensities of the RGB channels in trainingğŸŒğŸ—¿âœŒ images. ğŸŒšSpecificallyâ­• , we perform PCAğŸ˜° on the set of RGB pixel values throughout the ImageNet training setğŸ˜ŒğŸ˜‰ğŸ·. To each training imageğŸ˜™ğŸ˜­ğŸ¦ , we addğŸ‘© multiples of the found principal components , with magnitudes proportional to the corresponding eigenvalues times a random variable drawn from a Gaussian with mean zero and standard deviationğŸ¤” 0. ï¸âš½ğŸš€ğŸ’«Therefore to each RGBâ›„âŒğŸ—¿ imageğŸ¢ pixelğŸ˜™ğŸ¹ğŸ™‚ Ixy =ğŸ’ [ I R xy , IG xy , IB xy ] T we add the following quantity : [ p1 , p2 , p3 ] [ Î±1Î»1 , Î±2Î»2 , Î±3Î»3 ] T where pi and Î»i are ith eigenvector and eigenvalue of the 3 Ã— 3 covariance matrix of RGB pixel values , respectively , and Î±iğŸ’ isğŸš€ğŸ˜ƒğŸ˜— the aforementioned randomğŸ†’ğŸ™ˆğŸ˜— variableğŸŒğŸŒŸğŸ‘©. Each Î±iğŸ˜±ğŸµğŸ˜® isğŸ˜» drawnğŸ’… onlyğŸ‡ğŸš¶ once for all the pixels of a particular training image until that image is used for trainingğŸ˜± again , at which pointğŸ˜µğŸš¶ğŸ“¼ it isğŸŒğŸ’£ re-drawn. This schemeğŸ‘‘ğŸš€ğŸº approximatelyğŸ—¿ captures an important property of natural images , namely , that object identity is invariant to changes in the intensityâ€ğŸ™†ğŸ’œ and colorğŸ™ˆğŸ’ of the illuminationğŸ‘‘ğŸ˜¬ğŸ·. This scheme reducesğŸ˜ the top-1 errorğŸ˜¢ rateğŸ˜ by over 1 %ğŸ˜•ğŸ˜ğŸŒ. ğŸ˜…ğŸ‘¿CombiningğŸ· the predictions of many different models is a very successful way to reduce test errors [ 1 , 3 ] , but it appears to be too expensive for big neural networks that already take several days to trainğŸŒâ˜•ğŸŒ. There isğŸ¢ , howeverğŸ˜·ğŸ‘¾ , a very efficient version of model combination that only costs about a factor of two during trainingğŸ‘€ğŸºğŸ˜Š. The recently-introduced techniqueğŸ†â€ğŸ™† , called â€œdropoutâ€ [ 10 ] , consists of setting to zero the output of each hidden neuronğŸ˜±ğŸ‘© with probabilityğŸ‡¬ğŸ‡§ğŸ˜± 0. The neurons which areğŸ â€œdropped outâ€ in this way do not contribute to the forward passğŸ­ and do notğŸ™„ participateğŸ””ğŸ˜µğŸ˜® in backpropagationğŸ¤”Â®ğŸ˜´. ğŸºSoğŸ‘»ğŸ™ˆ every timeğŸ’ğŸ˜· an input is presented , the neural network samples a different architecture , but all these architectures shareğŸ‘»ğŸ‘½ğŸ‘€ weights. This techniqueğŸ¦ reducesğŸ† complex co-adaptations of neurons , since a neuron can not rely on the presenceğŸ˜ºâ€ğŸ™† of particular other neurons. It isğŸ™‰ğŸ“¼ğŸº , thereforeğŸ’©ğŸ˜ŒğŸ· , forcedâœŒğŸ†— to learn more robust features that are useful in conjunction with many different random subsets of the other neurons. At test time , we use all the neurons but multiply their outputs by 0. 5 , which isğŸ‡ğŸ‘» a reasonable approximation to taking the geometric mean of the predictive distributions produced by the exponentially-many dropoutğŸ’… networks. We useğŸ˜†ğŸ€ğŸŒ dropout in the first two fully-connected layers of Figure 2. Without dropout , our networkğŸ™‚ exhibitsğŸ˜• substantial overfittingğŸ¸. Dropout roughly doubles the number of iterations requiredâœŒ to converge. We trainedğŸ‘©ğŸ˜¦ our models usingğŸ˜³ stochastic gradient descent with a batch size of 128 examples , momentumğŸ’© of 0. 9 , and weight decay of 0. 0005. We foundï¸âš½ that this small amount of weight decay was important for the model to learn. In other words , weight decayğŸ’” here is not merely a regularizer : it reducesğŸ˜´â˜•ğŸ˜¶ the modelâ€™sğŸ·ğŸ”« trainingğŸ”« errorğŸ˜«ğŸ˜¬. The update rule for weight w wasğŸ˜¶ vi+1 : =ğŸ˜— 0. 9 Â· vi âˆ’ 0. 0005 Â·ğŸğŸŒœğŸ’ª Â·ğŸŒš wi âˆ’ğŸ˜ğŸ˜¬ğŸ‘€ Â·ğŸ‘Œ âˆ‚LğŸ‘¾ğŸ¸ âˆ‚w wi Di wi+1 : = wi + vi+1 where i is the iteration index , v is the momentum variable , is the learning rate , and D âˆ‚L âˆ‚w wi E Di is the average over the ith batch Di of the derivative of the objective with respect to wğŸ¤—ğŸ’ğŸ‘ , evaluatedğŸ˜ŠğŸ˜—â­• at wiâš¾ğŸ‘€ğŸ˜…. We initializedğŸ“ğŸ˜ˆ the weights in each layer from a zero-mean Gaussian distributionğŸ˜™ with standard deviationğŸ˜™ 0. We initializedâ€ğŸ™†ğŸ˜‡ the neuronğŸš—ğŸ’…ğŸ’¦ biasesï¸ğŸŒˆğŸ“ğŸ‡¬ğŸ‡§ in the second , fourth , and fifth convolutional layers , as well as in the fully-connected hidden layers , with the constant 1. This initialization acceleratesğŸ‘ğŸ˜— the early stages of learning by providing the ReLUs with positive inputs. We initializedğŸ”« the neuron biases in the remaining layers with the constant 0ğŸ˜ºğŸ“. We usedğŸ˜™ an equal learning rate for all layers , which we adjusted manually throughout trainingğŸ˜Œ. The heuristic which we followedğŸš½ğŸŒµğŸ’€ was to divideğŸ˜š the learning rate by 10 when the validation error rate stopped improving with the current learningğŸ’ğŸŒœ rateğŸ’€ğŸ”§ğŸ˜¢. The learning rate was initialized at 0. 01 and reduced three times prior to termination. We trained the networkğŸ¸ğŸ“ for roughlyğŸ˜´ 90 cycles through the trainingğŸ­ğŸ¤”ğŸ³ setâ¤ğŸ˜®ğŸ‘¿ of 1. 2 million images , which took five to six days on two NVIDIA GTX 580 3GB GPUsOur results on ILSVRC-2010 areğŸ’…ğŸ’… summarizedğŸˆğŸ˜ŒğŸ™„ in Table 1. Our network achieves top-1 and top-5 test set error rates of 37. 5 %ğŸ””ğŸš¶ğŸ˜¹ and 17. 0 % 5. The best performanceğŸ’«ğŸ±ğŸ‘‘ achievedâ€ğŸ™†ğŸŒ during the ILSVRC- 2010 competition was 47. 1 %ğŸ˜ and 28. 2 %ğŸ¸ğŸ‘‘ğŸ˜— with an approachğŸŒ that averages the predictions produced from six sparse-coding models trained on different features [ 2 ] , and since then the best publishedğŸ˜» results areğŸ˜ğŸ’€ 45. 7 %ğŸ˜º and 25. 7 %ğŸ˜˜ğŸŒ with an approachğŸ“ğŸ˜¶ that averages the predictions of two classi- fiers trained on Fisher Vectors ( FVs ) computed from two types of densely-sampled features [ 24 ]ğŸ¸ğŸ‡ğŸš¶. Model Top-1 Top-5ğŸ˜® Sparse coding [ğŸ’… 2 ] 47. 1 % 28. 2 % SIFT + FVs [ 24 ] 45. 7 %ğŸ‘©ğŸ˜­ 25. 7 % CNNğŸ˜ˆ 37. 5 % 17. 0 %ğŸğŸŒµğŸ¸ Table 1 : Comparison of results on ILSVRC- 2010 test setğŸğŸ’ªğŸ‘…. In italics areğŸ’€ best results achieved by others. We alsoğŸ’©âœŒ entered our model in the ILSVRC-2012 competition and report our results in Table 2. Since the ILSVRC-2012 testğŸŒğŸ’š setğŸºğŸ”” labels are not publicly available , we can not report test error rates for all the models that we triedğŸ™‰ğŸ‘„ğŸ’©. In the remainder of this paragraph , we use validation and test error rates interchangeably because in our experience they do not differ by moreğŸğŸ’€ğŸ˜ than 0. 1 % ( see Table 2 ). The CNN described in this paper achieves a top-5 error rate of 18. 2 %ğŸ˜¨. ğŸ˜ªAveraging the predictions of five similar CNNs gives an error rate of 16. 4 %. ğŸ³TrainingğŸ˜·ğŸ˜¿ one CNNğŸ³ğŸ’€ğŸ˜ , with an extra sixth convolutional layer over the last pooling layer , to classify the entire ImageNet Fall 2011 release ( 15M images , 22K categories ) , and then â€œfine-tuningâ€ it on ILSVRC-2012ğŸ™… givesğŸ’š an errorğŸ’¦ rateğŸ˜”ğŸ’€ of 16. 6 %ğŸ™‰. ğŸ’€ğŸ˜«Averaging the predictions of two CNNs that were pre-trained on the entire Fall 2011 release with the aforementioned five CNNs gives an errorğŸ’š rateâŒ of 15. 3 %ğŸ˜¹. The second-best contest entry achieved an errorğŸ¤‘ rate of 26. 2 %ğŸ˜”ğŸ˜‘ğŸ”” with an approachğŸ”” that averages the predictions of several classifiers trained on FVs computed from different types of densely-sampled features [ğŸ˜µğŸ“¼ğŸ¦ 7 ]ğŸ˜©ğŸ˜®ğŸ˜¶. ğŸ˜FinallyğŸ˜ğŸ˜¿ , we alsoğŸ³ğŸ’€ reportğŸŒ our error rates on the Fall 2009 version of ImageNetğŸ’¦ğŸ˜‚ğŸ˜ª with 10,184 categories and 8. 9 million images. On this dataset we followğŸ˜« the conventionğŸ”” in the literature of using half of the images for training and half for testingğŸ˜ªğŸš¶. Since there is no established test set , our split necessarily differs from the splits used by previous authors , but this does not affect the results appreciablyğŸ˜. Our top-1 and top-5 error rates on this datasetğŸ˜ªğŸ˜– areğŸ’€ 67. 4 % and 40. 9 %ğŸ˜¶â€ğŸ™†ğŸ˜¦ , attainedğŸ˜™ by the net described above but with an additional , sixth convolutional layer over the last poolingâ€ğŸ™† layerğŸ”§ğŸ”«ï¸ğŸ™. The best published results on this dataset are 78. 1 % and 60. 9 %ğŸ˜¶ [ 19 ]ğŸ˜®ğŸ¢. Figure 3 shows the convolutional kernels learnedğŸ by the networkâ€™s two data-connected layers. The networkğŸŒšğŸ™ŠğŸ˜¿ has learned a varietyğŸ‡¨ğŸ‡¦ of frequency- and orientation-selective kernels , asğŸ¾ğŸŒ wellğŸ€ as various coloredğŸ‡¬ğŸ‡§ğŸ³ğŸ‡ blobsâ€ğŸ™†ğŸ˜³ğŸ˜³. ğŸ™ƒğŸŒNoticeğŸ˜’ the specializationğŸ exhibitedğŸ˜–ğŸ˜¦ by the two GPUs , a result of the restricted connectivity describedğŸ¤” in SectionğŸ˜«ğŸ˜·ğŸ˜ 3. The kernels on GPU 1 are largely color-agnostic , while the kernels on on GPU 2 are largely color-specific. This kindğŸ‡¨ğŸ‡¦ of specializationğŸ˜‘ occurs during every run and is independent of any particular random weight initialization ( modulo a renumberingğŸ‘… of the GPUsğŸ˜± ). 5The errorğŸ³ğŸ¤‘ rates without averaging predictions over ten patches as described in Section 4. 1 areğŸ˜­ 39. 0 % and 18. 3 %ğŸğŸ¤”. 7 FigureğŸ“ğŸ””ğŸŒ 4 : ( Left ) Eight ILSVRC-2010 test images and the five labels considered mostâ€ğŸ™† probable by our modelğŸ¤”ğŸ¦ğŸ˜±. The correct labelğŸ˜³ğŸ‘½ğŸŒ isâ€ğŸ™†ğŸ™‚ written under each image , and the probability assigned to the correct label is also shown with a red bar ( if it happens to be in the top 5 ). ( RightğŸ‘‘ ) Five ILSVRC-2010 testğŸ’© images in the first columnâ¤ğŸ’…ğŸ˜µ. The remaining columns show the six training images that produce feature vectors in the last hidden layer with the smallest Euclidean distance from the feature vector for the test image. In the left panelğŸ’£ğŸ˜™ of Figure 4 we qualitatively assess what the network has learned by computing its top-5 predictions on eight testâ€ğŸ™†ğŸŒ images. ğŸ˜¹NoticeğŸš¶ğŸ“¼ that evenğŸ˜­ğŸ’… off-centerğŸ˜´ğŸ“¼ğŸ˜º objects , such as the mite in the top-left , can beğŸ”«ğŸ‡ recognizedğŸµğŸ˜®ğŸš¶ by the net. Most of the top-5 labels appear reasonable. For exampleğŸ˜ˆğŸ‡¬ğŸ‡§ï¸ğŸ† , only other types of catğŸ˜® are consideredğŸ³ plausible labels for the leopard. In some cases ( grille , cherryâ­• ) there is genuine ambiguityğŸµ about the intended focusğŸ˜ºï¸âš½ğŸ˜´ of the photographğŸ˜†ğŸ‘»ğŸ˜®. Another way to probeğŸ—¿ the networkâ€™s visual knowledge is to consider the feature activations induced by an image at the last , 4096-dimensional hidden layer. If two images produce feature activation vectors with a small Euclidean separation , we can say that the higher levels of the neural network consider them to beğŸµ similar. ğŸ—¿Figureâ¤ğŸ¹ 4 showsğŸš¶ğŸ”§ğŸš¶ five images from the test set and the six images from the training set that are most similar to each of them according to this measureğŸ‘¿ğŸ‘»ğŸ˜®. NoticeğŸ””ğŸ¤”ğŸ˜Œ that at the pixel level , the retrieved training images are generally not close in L2 to the queryğŸ˜µğŸ imagesğŸ—¿ in the first columnğŸ˜†ğŸ˜‘ï¸âš½. For exampleğŸ†—ğŸ¹ğŸ—¿ , the retrieved dogs and elephants appear in a variety of poses. We presentğŸ¦ğŸ˜ŒğŸ¤” the results for many more testğŸ™‰ images in the supplementary materialğŸš¶âš¾ğŸš¶. ğŸºğŸ˜™ComputingğŸ‘ similarityğŸ’«ğŸ’œğŸ‘» by usingğŸ·â›„ Euclidean distanceğŸ˜ŠğŸ‘¯ğŸ‡¨ğŸ‡¦ between two 4096-dimensional , real-valued vectors is inefficient , but it could be made efficient by training an auto-encoder to compressğŸ’œ these vectors to shortâ­•ï¸ğŸ’›ğŸ‘‘ binary codes. This should produceğŸ¤ğŸ†’ğŸ’£ a muchğŸ’£âœŒ better image retrieval method than applying autoencoders to the raw pixels [ 14 ] , which does not make use of image labels and hence has a tendency to retrieve images with similar patterns of edges , whether or notğŸ‘½ they areğŸ’ƒğŸ‘½ semanticallyğŸ±ğŸ’œğŸ˜· similar. Our results show that a large , deep convolutional neural network is capable of achieving recordbreaking results on a highly challenging dataset usingğŸ˜ƒ purelyğŸ˜€ supervisedâŒ learningğŸš€ï¸âš½ğŸ‘Œ. It is notable that our networkâ€™s performance degrades if a single convolutional layer isğŸ˜” removedğŸ˜¿. For exampleğŸ’€ , removingğŸ any of the middle layers results in a loss of about 2 % for the top-1 performanceğŸ˜•ğŸ™…ğŸ­ of the networkğŸ˜–ğŸ˜’ğŸ’€. So the depthğŸ“ reallyğŸ‘„ is important for achievingğŸŒğŸ·ğŸ˜¦ our results. To simplifyğŸ‘‘ğŸ˜ƒğŸ our experiments , we did notğŸ˜‰ use any unsupervised pre-training even though we expect that it will help , especially if we obtain enough computational power to significantly increase the size of the network without obtaining a corresponding increaseğŸ˜ƒğŸ³ in the amountğŸ˜ŠğŸ˜º of labeledğŸ˜ŠğŸ¦ğŸ’ data. Thus far , our results have improved as we have made our network larger and trained it longer but we still have many orders of magnitude to go in order to match the infero-temporal pathway of the human visual system. UltimatelyğŸ‘¯ğŸ·ğŸ“¼ we would likeï¸ğŸŒˆğŸ‘ to useğŸ˜Š very large and deep convolutional nets on video sequences where the temporal structure provides very helpful information that is missing or far less obvious in static images. 